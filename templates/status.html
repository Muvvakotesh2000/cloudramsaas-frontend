<!DOCTYPE html>
<html lang="en">
<head>
  <title>Cloud RAM Dashboard</title>

  <!-- Supabase + auth helper -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/static/config.js" defer></script>
  <script src="/static/status_auth.js?v=6" defer></script>

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      color: #fff;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    .spinner {
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 3px solid #fff;
      border-radius: 50%;
      border-top: 3px solid #00c4cc;
      animation: spin 1s linear infinite;
      margin-left: 10px;
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .button {
      background-color: #00c4cc;
      border: none;
      color: white;
      padding: 10px 18px;
      margin: 8px 4px;
      font-size: 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .button:hover { background-color: #009fa3; }
    .button:disabled { background-color: #999; cursor: not-allowed; opacity: 0.6; }
    .danger { background-color: #ff5b5b; }
    .danger:hover { background-color: #e04747; }

    iframe { width: 100%; height: 500px; border: none; }
    #tasks { min-width: 320px; min-height: 140px; }

    .panel {
      width: min(920px, 95vw);
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.20);
      border-radius: 10px;
      padding: 14px 16px;
      margin-top: 12px;
    }
    .muted { opacity: 0.9; font-size: 13px; }
    .ok { color: lightgreen; }
    .bad { color: #ffb3b3; }
    code {
      background: rgba(0,0,0,0.25);
      padding: 2px 6px;
      border-radius: 6px;
    }
  </style>
</head>

<body>
  <h1>Cloud RAM Dashboard</h1>
  <div id="status-text">Loading...</div>

  <!-- ‚úÖ Local Agent Panel -->
  <div id="agent-panel" class="panel" style="display:none;">
    <div style="font-weight:bold; font-size:16px;">Local Agent Required</div>
    <div class="muted" style="margin-top:6px;">
      This app uses a Local Agent on your PC for secure task discovery and local file sync.
      The browser cannot install or start it automatically ‚Äî you‚Äôll do a one-time setup.
    </div>

    <div id="agent-status" style="margin-top:10px; font-weight:bold;"></div>

    <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
      <a id="agent-download" class="button" href="#" target="_blank" rel="noopener">Download Agent</a>
      <button id="copy-install-cmd" class="button">Copy Install Command</button>
      <button id="retry-agent" class="button">Retry</button>
    </div>

    <div class="muted" style="margin-top:10px;">
      After install, the agent should run automatically on login.
      If you just installed it, wait ~5 seconds and click <b>Retry</b>.
    </div>

    <div class="muted" style="margin-top:10px;">
      Health check endpoint: <code>http://127.0.0.1:7071/health</code>
    </div>
  </div>

  <div style="margin-top:12px;">
    <button class="button danger" id="stop-vm-btn">Stop VM</button>
    <span id="stop-spinner" style="display:none;" class="spinner"></span>
    <p id="stop-status" style="margin-top: 10px; font-weight: bold;"></p>
  </div>

  <h2>Running Tasks</h2>
  <div id="tasks-container">
    <p id="task-loading">Fetching tasks...</p>
    <select id="tasks" multiple></select>
    <div>
      <button class="button" id="migrate-btn">Migrate Selected Tasks</button>
      <span id="migration-spinner" style="display:none;" class="spinner"></span>
      <p id="migration-status" style="margin-top: 10px; font-weight: bold;"></p>

      <button class="button" id="migrate-vscode-btn" style="display:none;">Migrate VSCode Project</button>
      <span id="vscode-spinner" style="display:none;" class="spinner"></span>
      <p id="vscode-status" style="margin-top: 10px; font-weight: bold;"></p>

      <button class="button" id="save-local-btn">Save Project to Local</button>
      <span id="save-local-spinner" style="display:none;" class="spinner"></span>
      <p id="save-local-status" style="margin-top: 10px; font-weight: bold;"></p>
    </div>
  </div>

  <h2>VM GUI (VNC)</h2>
  <div id="vnc-container">
    <p id="vnc-loading">Loading VM GUI...</p>
    <iframe id="vnc-iframe" style="display: none;"></iframe>
    <button class="button" onclick="toggleFullscreen()" style="margin-top: 10px;">Toggle Fullscreen</button>
  </div>

  <script>
    let taskArray = [];
    let vmIp = null;
    let vmId = null;

    // ========= Local Agent config =========
    const AGENT_BASE = "http://127.0.0.1:7071";
    // Host your agent installer somewhere you control (backend/static/S3/etc)
    const AGENT_INSTALL_URL = "/static/agent/CloudRAMS-Agent-Setup.exe"; // <-- change if needed

    // One-time install command (user copies & runs in PowerShell)
    // Replace with your real command. Example uses a downloaded installer.
    function buildInstallCommand() {
      // This is an example. Adjust file name and args as needed.
      // You can also host a .ps1 script and use iwr to download and execute.
      return [
        '$ErrorActionPreference="Stop"',
        'Write-Host "Downloading CloudRAMS Local Agent installer..."',
        `Invoke-WebRequest -Uri "${window.location.origin}${AGENT_INSTALL_URL}" -OutFile "$env:TEMP\\CloudRAMS-Agent-Setup.exe"`,
        'Write-Host "Running installer..."',
        'Start-Process "$env:TEMP\\CloudRAMS-Agent-Setup.exe" -ArgumentList "/S" -Wait',
        'Write-Host "Done. The agent should start automatically."'
      ].join(" ; ");
    }

    // ========= Helpers =========
    async function apiBase() {
      const cfg = await window.loadAppConfig();
      return (cfg.API_BASE_URL || "http://127.0.0.1:8000").replace(/\/$/, "");
    }

    async function fetchJson(url, opts = {}) {
      const r = await fetch(url, opts);
      const text = await r.text();
      let data;
      try { data = JSON.parse(text); } catch { data = { raw: text }; }
      if (!r.ok) throw new Error(data.detail || data.error || data.raw || `HTTP ${r.status}`);
      return data;
    }

    async function isAgentOnline() {
      try {
        await fetchJson(`${AGENT_BASE}/health`);
        return true;
      } catch {
        return false;
      }
    }

    function showAgentPanel(show, message = "", ok = false) {
      const panel = document.getElementById("agent-panel");
      const status = document.getElementById("agent-status");
      if (!panel || !status) return;

      panel.style.display = show ? "block" : "none";
      if (message) {
        status.textContent = message;
        status.className = ok ? "ok" : "bad";
      }
    }

    async function ensureAgentOrShowHelp() {
      const online = await isAgentOnline();
      if (online) {
        showAgentPanel(false);
        return true;
      }

      // Show panel with setup actions
      const dl = document.getElementById("agent-download");
      if (dl) dl.href = AGENT_INSTALL_URL;

      showAgentPanel(true, "‚ùå Local Agent is not running. Please install/start it, then click Retry.", false);
      return false;
    }

    // ========= Dashboard init =========
    document.addEventListener("DOMContentLoaded", async () => {
      const stopBtn = document.getElementById("stop-vm-btn");
      if (stopBtn) stopBtn.addEventListener("click", stopVmNow);

      const migrateBtn = document.getElementById("migrate-btn");
      if (migrateBtn) migrateBtn.addEventListener("click", migrateSelectedTasks);

      const migrateVSCodeBtn = document.getElementById("migrate-vscode-btn");
      if (migrateVSCodeBtn) migrateVSCodeBtn.addEventListener("click", migrateVSCodeProject);

      const saveBtn = document.getElementById("save-local-btn");
      if (saveBtn) saveBtn.addEventListener("click", saveProjectToLocal);

      const retryBtn = document.getElementById("retry-agent");
      if (retryBtn) retryBtn.addEventListener("click", async () => {
        const ok = await ensureAgentOrShowHelp();
        if (ok) {
          showAgentPanel(false, "", true);
          // If agent is up now, refresh tasks (depends on your design)
          fetchLocalTasksViaAgent();
        }
      });

      const copyBtn = document.getElementById("copy-install-cmd");
      if (copyBtn) copyBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(buildInstallCommand());
          showAgentPanel(true, "‚úÖ Install command copied. Paste into PowerShell and run once.", true);
        } catch {
          showAgentPanel(true, "‚ùå Could not copy. Copy manually from console (see DevTools).", false);
          console.log("INSTALL CMD:\n", buildInstallCommand());
        }
      });

      // start dashboard load
      await initDashboard();
    });

    // ---------------------------
    // ‚úÖ ALWAYS refresh VM from backend (/my_vm)
    // ---------------------------
    async function fetchMyVmWithRetries(maxTries = 30, delayMs = 5000) {
      const headers = await window.getAuthHeaders();
      const base = await apiBase();

      for (let i = 1; i <= maxTries; i++) {
        const resp = await fetch(`${base}/my_vm`, { headers });

        const text = await resp.text();
        let info;
        try { info = JSON.parse(text); } catch { info = { raw: text }; }

        if (!resp.ok) {
          throw new Error(info.detail || info.error || info.raw || `my_vm failed (${resp.status})`);
        }

        if (!info.exists) return info;

        // if running/pending but ip missing, wait and retry
        if ((info.state === "running" || info.state === "pending") && !info.ip) {
          document.getElementById("status-text").innerHTML =
            `‚è≥ VM is ${info.state}. Waiting for public IP... (try ${i}/${maxTries})`;
          await new Promise(r => setTimeout(r, delayMs));
          continue;
        }

        return info;
      }

      throw new Error("Timed out waiting for VM IP. Try again in a minute.");
    }

    async function initDashboard() {
      try {
        document.getElementById("status-text").innerHTML = "‚è≥ Loading VM info...";

        const info = await fetchMyVmWithRetries(36, 5000); // ~3 minutes

        if (!info.exists) {
          document.getElementById("status-text").innerHTML =
            "‚ùå No VM found for your account. Go to Allocate page and create one.";
          return;
        }

        vmId = info.vm_id || null;
        vmIp = info.ip || null;

        if (vmId) localStorage.setItem("vm_id", vmId);
        if (vmIp) localStorage.setItem("vm_ip", vmIp);

        if (info.state === "stopped" || info.state === "stopping") {
          document.getElementById("status-text").innerHTML =
            `üü° VM is ${info.state}. Go to Allocate page and click Resume.`;
          return;
        }

        if (!vmIp) {
          document.getElementById("status-text").innerHTML =
            "‚ö†Ô∏è VM exists but has no IP yet. Please wait and refresh.";
          return;
        }

        // Load VNC first (best UX)
        loadVncGui();

        // Then load RAM + tasks
        await fetchRamUsage();

        // Agent-dependent task discovery
        const agentOk = await ensureAgentOrShowHelp();
        if (agentOk) {
          // Recommended: tasks from local agent (not from Render backend)
          fetchLocalTasksViaAgent();
        } else {
          // If you still want fallback server tasks, you can call it here (optional)
          // fetchServerSideTasksFallback();
        }

      } catch (e) {
        console.error("initDashboard failed:", e);
        document.getElementById("status-text").innerHTML = `‚ùå ${e.message || e}`;
      }
    }

    async function fetchRamUsage() {
      const headers = await window.getAuthHeaders();

      const base = await apiBase();
      const response = await fetch(`${base}/ram_usage?vm_ip=${encodeURIComponent(vmIp)}`, { headers });
      if (!response.ok) {
        const txt = await response.text().catch(() => "");
        throw new Error(`RAM usage failed (${response.status}): ${txt || response.statusText}`);
      }

      const data = await response.json();
      document.getElementById("status-text").innerHTML = `
        ‚úÖ Cloud RAM Running at ${vmIp} <br>
        üîπ Total RAM: ${(data.total_ram / (1024 ** 3)).toFixed(2)} GB<br>
        üîπ Used RAM: ${(data.used_ram / (1024 ** 3)).toFixed(2)} GB (${data.percent_used}%)<br>
        üîπ Available RAM: ${(data.available_ram / (1024 ** 3)).toFixed(2)} GB
      `;
    }

    // ---------------------------
    // ‚úÖ Stop button (reliable)
    // ---------------------------
    async function stopVmNow() {
      const stopBtn = document.getElementById("stop-vm-btn");
      const spinner = document.getElementById("stop-spinner");
      const statusEl = document.getElementById("stop-status");

      try {
        statusEl.textContent = "";
        statusEl.style.color = "white";
        spinner.style.display = "inline-block";
        stopBtn.disabled = true;

        const headers = await window.getAuthHeaders();
        const vm_id = localStorage.getItem("vm_id");
        if (!vm_id) throw new Error("No vm_id found in localStorage.");

        const base = await apiBase();
        const resp = await fetch(`${base}/stop_vm`, {
          method: "POST",
          headers: { ...headers, "Content-Type": "application/json" },
          body: JSON.stringify({ vm_id })
        });

        const text = await resp.text();
        let data;
        try { data = JSON.parse(text); } catch { data = { raw: text }; }

        if (!resp.ok) throw new Error(data.detail || data.error || data.raw || "Stop failed.");

        statusEl.style.color = "lightgreen";
        statusEl.textContent = "‚úÖ Stop requested. VM will enter STOPPED state shortly.";

      } catch (e) {
        statusEl.style.color = "crimson";
        statusEl.textContent = `‚ùå ${e.message || e}`;
      } finally {
        spinner.style.display = "none";
        stopBtn.disabled = false;
      }
    }

    // ---------------------------
    // ‚úÖ Tasks list (preferred: local agent)
    // ---------------------------
    async function fetchLocalTasksViaAgent() {
      const taskList = document.getElementById("tasks");
      const loadingText = document.getElementById("task-loading");

      loadingText.style.display = "block";
      loadingText.style.color = "white";
      loadingText.innerText = "Fetching local tasks via Agent...";
      taskList.innerHTML = "";
      taskArray = [];

      try {
        const data = await fetchJson(`${AGENT_BASE}/running_tasks`);

        loadingText.style.display = "none";

        if (!data.tasks || data.tasks.length === 0) {
          taskList.innerHTML = "<option>No running tasks found</option>";
          return;
        }

        data.tasks.forEach(task => {
          if (['notepad++.exe', 'chrome.exe', 'Code.exe'].includes(task.name)) {
            taskArray.push({ pid: task.pid, name: task.name });
          }
        });

        const hasVSCode = (data.tasks || []).some(t => (t.name || "").toLowerCase() === "code.exe");
        document.getElementById("migrate-vscode-btn").style.display = hasVSCode ? "inline-block" : "none";

        populateDropdown();
        loadingText.style.display = "block";
        loadingText.innerText = `${taskArray.length} tasks fetched.`;

      } catch (err) {
        console.error("‚ùå Agent task fetch failed:", err);
        loadingText.style.display = "block";
        loadingText.style.color = "crimson";
        loadingText.innerText = `‚ùå Failed to fetch tasks from Agent: ${err.message || err}`;
        // Show panel again if agent is down
        showAgentPanel(true, "‚ùå Agent is not responding. Start it and click Retry.", false);
      }
    }

    function populateDropdown() {
      const taskList = document.getElementById("tasks");
      taskList.innerHTML = "";

      if (taskArray.length === 0) {
        const opt = document.createElement("option");
        opt.text = "No tasks available";
        taskList.add(opt);
        return;
      }

      taskArray.forEach(t => {
        const opt = document.createElement("option");
        opt.value = t.pid;
        opt.text = `${t.name} (PID: ${t.pid})`;
        taskList.add(opt);
      });
    }

    // ---------------------------
    // ‚úÖ Save Project to Local (agent recommended)
    // ---------------------------
    async function saveProjectToLocal() {
      const btn = document.getElementById("save-local-btn");
      const spinner = document.getElementById("save-local-spinner");
      const statusEl = document.getElementById("save-local-status");

      try {
        spinner.style.display = "inline-block";
        btn.disabled = true;
        statusEl.style.color = "white";
        statusEl.textContent = "";

        const agentOk = await ensureAgentOrShowHelp();
        if (!agentOk) throw new Error("Local Agent not running.");

        const project_name = prompt("Enter project folder name to save (example: CloudRAMSaaS):");
        if (!project_name) return;

        const info = await fetchMyVmWithRetries(6, 3000);
        if (!info.exists || !info.ip) throw new Error("VM not running or missing IP.");
        vmIp = info.ip;

        // Preferred: call backend to prepare zip/artifact + agent downloads it
        // Option A: call your backend endpoint (protected) and let it stream to agent
        // Option B: call agent directly and pass it a signed URL from backend

        // Here is a simple pattern: ask backend for a signed download url, then tell agent to download.
        const headers = await window.getAuthHeaders();
        const base = await apiBase();

        const prep = await fetchJson(`${base}/save_project_to_local`, {
          method: "POST",
          headers: { ...headers, "Content-Type": "application/json" },
          body: JSON.stringify({ vm_ip: vmIp, project_name })
        });

        // If your backend already performs the full save, keep it.
        // If instead it returns a URL, call agent to download:
        // await fetchJson(`${AGENT_BASE}/download`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ url: prep.url }) });

        statusEl.style.color = "lightgreen";
        statusEl.textContent = `‚úÖ ${prep.message || "Saved successfully."}`;

      } catch (e) {
        statusEl.style.color = "crimson";
        statusEl.textContent = `‚ùå ${e.message || e}`;
      } finally {
        spinner.style.display = "none";
        btn.disabled = false;
      }
    }

    // ---------------------------
    // ‚úÖ Migrate (protected) - uses refreshed vmIp
    // ---------------------------
    async function migrateSelectedTasks() {
      const migrateBtn = document.getElementById("migrate-btn");
      const spinner = document.getElementById("migration-spinner");
      const statusEl = document.getElementById("migration-status");
      const taskSelect = document.getElementById("tasks");

      try {
        spinner.style.display = "inline-block";
        migrateBtn.disabled = true;
        statusEl.style.color = "white";
        statusEl.textContent = "";

        const info = await fetchMyVmWithRetries(6, 3000);
        if (!info.exists || !info.ip) throw new Error("VM not running or missing IP.");
        vmIp = info.ip;
        localStorage.setItem("vm_ip", vmIp);

        const selectedOptions = Array.from(taskSelect.selectedOptions);
        if (selectedOptions.length === 0) {
          statusEl.textContent = "‚ö†Ô∏è Select at least one task.";
          return;
        }

        const task_names = selectedOptions.map(opt => opt.text.split(" (PID:")[0].trim());

        const headers = await window.getAuthHeaders();
        const base = await apiBase();

        const resp = await fetch(`${base}/migrate_tasks/`, {
          method: "POST",
          headers: { ...headers, "Content-Type": "application/json" },
          body: JSON.stringify({ task_names, vm_ip: vmIp })
        });

        const text = await resp.text();
        let result;
        try { result = JSON.parse(text); } catch { result = { raw: text }; }

        if (!resp.ok) {
          throw new Error(result.detail || result.error || result.raw || "Migration failed.");
        }

        const okCount = (result.results || []).filter(r => r.success).length;
        const total = (result.results || []).length;

        statusEl.style.color = "lightgreen";
        statusEl.textContent = `‚úÖ Migration completed: ${okCount}/${total} succeeded.`;

      } catch (err) {
        console.error(err);
        statusEl.style.color = "crimson";
        statusEl.textContent = `‚ùå ${err.message || err}`;
      } finally {
        spinner.style.display = "none";
        migrateBtn.disabled = false;
      }
    }

    async function migrateVSCodeProject() {
      const btn = document.getElementById("migrate-vscode-btn");
      const spinner = document.getElementById("vscode-spinner");
      const statusEl = document.getElementById("vscode-status");

      try {
        spinner.style.display = "inline-block";
        btn.disabled = true;
        statusEl.style.color = "white";
        statusEl.textContent = "";

        const info = await fetchMyVmWithRetries(10, 3000);
        if (!info.exists || !info.ip) throw new Error("VM not running or missing IP.");
        vmIp = info.ip;
        localStorage.setItem("vm_ip", vmIp);

        const headers = await window.getAuthHeaders();
        const base = await apiBase();

        const resp = await fetch(`${base}/migrate_vscode/`, {
          method: "POST",
          headers: { ...headers, "Content-Type": "application/json" },
          body: JSON.stringify({ vm_ip: vmIp })
        });

        const text = await resp.text();
        let data;
        try { data = JSON.parse(text); } catch { data = { raw: text }; }

        if (!resp.ok) throw new Error(data.detail || data.error || data.raw || "VSCode migration failed.");

        statusEl.style.color = "lightgreen";
        statusEl.textContent = `‚úÖ VSCode migrated. Opened on VM: ${data.opened_path || "unknown"}`;

      } catch (e) {
        statusEl.style.color = "crimson";
        statusEl.textContent = `‚ùå ${e.message || e}`;
      } finally {
        spinner.style.display = "none";
        btn.disabled = false;
      }
    }

    // ---------------------------
    // ‚úÖ VNC iframe uses vmIp
    // ---------------------------
    function loadVncGui() {
      if (!vmIp) {
        document.getElementById("vnc-loading").innerText =
          "‚ùå No VM IP found. Please ensure Cloud RAM is running.";
        return;
      }

      const vncUrl = `http://${vmIp}:8080/vnc.html?autoconnect=true&resize=scale`;
      const iframe = document.getElementById("vnc-iframe");
      const loading = document.getElementById("vnc-loading");

      iframe.src = vncUrl;

      iframe.onload = () => {
        loading.style.display = "none";
        iframe.style.display = "block";
      };

      iframe.onerror = () => {
        loading.style.color = "crimson";
        loading.innerText = "‚ùå Failed to load VM GUI inside iframe. Try opening VNC in a new tab.";
      };
    }

    function toggleFullscreen() {
      const iframe = document.getElementById("vnc-iframe");
      if (!document.fullscreenElement) {
        if (iframe.requestFullscreen) iframe.requestFullscreen();
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
      }
    }
  </script>
</body>
</html>
